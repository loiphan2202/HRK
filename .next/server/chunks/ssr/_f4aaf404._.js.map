{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/build/templates/app-page.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport {\n  AppPageRouteModule,\n  type AppPageRouteHandlerContext,\n} from '../../server/route-modules/app-page/module.compiled' with { 'turbopack-transition': 'next-ssr' }\n\nimport { RouteKind } from '../../server/route-kind' with { 'turbopack-transition': 'next-server-utility' }\n\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\nimport { getRequestMeta } from '../../server/request-meta'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { interopDefault } from '../../server/app-render/interop-default'\nimport { stripFlightHeaders } from '../../server/app-render/strip-flight-headers'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\nimport {\n  getFallbackRouteParams,\n  type FallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport {\n  isHtmlBotRequest,\n  shouldServeStreamingMetadata,\n} from '../../server/lib/streaming-metadata'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../client/components/app-router-headers'\nimport { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\nimport {\n  CachedRouteKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\nimport { FallbackMode, parseFallbackField } from '../../lib/fallback'\nimport RenderResult from '../../server/render-result'\nimport {\n  CACHE_ONE_YEAR,\n  HTML_CONTENT_TYPE_HEADER,\n  NEXT_CACHE_TAGS_HEADER,\n} from '../../lib/constants'\nimport type { CacheControl } from '../../server/lib/cache-control'\nimport { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\nimport { sendRenderResult } from '../../server/send-payload'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n\n// These are injected by the loader afterwards.\n\n/**\n * The tree created in next-app-loader that holds component segments and modules\n * and I've updated it.\n */\ndeclare const tree: LoaderTree\ndeclare const pages: any\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\n// INJECT:tree\n// INJECT:pages\n\nexport { tree, pages }\n\nimport GlobalError from 'VAR_MODULE_GLOBAL_ERROR' with { 'turbopack-transition': 'next-server-utility' }\n\nexport { GlobalError }\n\n// These are injected by the loader afterwards.\ndeclare const __next_app_require__: (id: string | number) => unknown\ndeclare const __next_app_load_chunk__: (id: string | number) => Promise<unknown>\n\n// INJECT:__next_app_require__\n// INJECT:__next_app_load_chunk__\n\nexport const __next_app__ = {\n  require: __next_app_require__,\n  loadChunk: __next_app_load_chunk__,\n}\n\nimport * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\n\nexport * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n  definition: {\n    kind: RouteKind.APP_PAGE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n    appPaths: [],\n  },\n  userland: {\n    loaderTree: tree,\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const initialPostponed = getRequestMeta(req, 'postponed')\n  // TODO: replace with more specific flags\n  const minimalMode = getRequestMeta(req, 'minimalMode')\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    query,\n    params,\n    parsedUrl,\n    pageIsDynamic,\n    buildManifest,\n    nextFontManifest,\n    reactLoadableManifest,\n    serverActionsManifest,\n    clientReferenceManifest,\n    subresourceIntegrityManifest,\n    prerenderManifest,\n    isDraftMode,\n    resolvedPathname,\n    revalidateOnlyGenerated,\n    routerServerContext,\n    nextConfig,\n    interceptionRoutePatterns,\n  } = prepareResult\n\n  const pathname = parsedUrl.pathname || '/'\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let { isOnDemandRevalidate } = prepareResult\n\n  const prerenderInfo = routeModule.match(pathname, prerenderManifest)\n  const isPrerendered = !!prerenderManifest.routes[resolvedPathname]\n\n  let isSSG = Boolean(\n    prerenderInfo ||\n      isPrerendered ||\n      prerenderManifest.routes[normalizedSrcPage]\n  )\n\n  const userAgent = req.headers['user-agent'] || ''\n  const botType = getBotType(userAgent)\n  const isHtmlBot = isHtmlBotRequest(req)\n\n  /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */\n  const isPrefetchRSCRequest =\n    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n    req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n\n  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n  const isRSCRequest =\n    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n\n  const isPossibleServerAction = getIsPossibleServerAction(req)\n\n  /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */\n  const couldSupportPPR: boolean = checkIsAppPPREnabled(\n    nextConfig.experimental.ppr\n  )\n\n  // When enabled, this will allow the use of the `?__nextppronly` query to\n  // enable debugging of the static shell.\n  const hasDebugStaticShellQuery =\n    process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n    typeof query.__nextppronly !== 'undefined' &&\n    couldSupportPPR\n\n  // When enabled, this will allow the use of the `?__nextppronly` query\n  // to enable debugging of the fallback shell.\n  const hasDebugFallbackShellQuery =\n    hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n  // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n  // prerender manifest and this is an app page.\n  const isRoutePPREnabled: boolean =\n    couldSupportPPR &&\n    ((\n      prerenderManifest.routes[normalizedSrcPage] ??\n      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n    )?.renderingMode === 'PARTIALLY_STATIC' ||\n      // Ideally we'd want to check the appConfig to see if this page has PPR\n      // enabled or not, but that would require plumbing the appConfig through\n      // to the server during development. We assume that the page supports it\n      // but only during development.\n      (hasDebugStaticShellQuery &&\n        (routeModule.isDev === true ||\n          routerServerContext?.experimentalTestProxy === true)))\n\n  const isDebugStaticShell: boolean =\n    hasDebugStaticShellQuery && isRoutePPREnabled\n\n  // We should enable debugging dynamic accesses when the static shell\n  // debugging has been enabled and we're also in development mode.\n  const isDebugDynamicAccesses =\n    isDebugStaticShell && routeModule.isDev === true\n\n  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n  // If we're in minimal mode, then try to get the postponed information from\n  // the request metadata. If available, use it for resuming the postponed\n  // render.\n  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n\n  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n  // we can use this fact to only generate the flight data for the request\n  // because we can't cache the HTML (as it's also dynamic).\n  const isDynamicRSCRequest =\n    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n  // Need to read this before it's stripped by stripFlightHeaders. We don't\n  // need to transfer it to the request meta because it's only read\n  // within this function; the static segment data should have already been\n  // generated, so we will always either return a static response or a 404.\n  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n  // being true for a revalidate due to modifying the base-server this.renderOpts\n  // when fixing this to correct logic it causes hydration issue since we set\n  // serveStreamingMetadata to true during export\n  let serveStreamingMetadata = !userAgent\n    ? true\n    : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n\n  if (isHtmlBot && isRoutePPREnabled) {\n    isSSG = false\n    serveStreamingMetadata = false\n  }\n\n  // In development, we always want to generate dynamic HTML.\n  let supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG ||\n    // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof initialPostponed === 'string' ||\n    // If this is a dynamic RSC request, then this render supports dynamic\n    // HTML (it's dynamic).\n    isDynamicRSCRequest\n\n  // When html bots request PPR page, perform the full dynamic rendering.\n  const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n\n  let ssgCacheKey: string | null = null\n  if (\n    !isDraftMode &&\n    isSSG &&\n    !supportsDynamicResponse &&\n    !isPossibleServerAction &&\n    !minimalPostponed &&\n    !isDynamicRSCRequest\n  ) {\n    ssgCacheKey = resolvedPathname\n  }\n\n  // the staticPathKey differs from ssgCacheKey since\n  // ssgCacheKey is null in dev since we're always in \"dynamic\"\n  // mode in dev to bypass the cache, but we still need to honor\n  // dynamicParams = false in dev mode\n  let staticPathKey = ssgCacheKey\n  if (!staticPathKey && routeModule.isDev) {\n    staticPathKey = resolvedPathname\n  }\n\n  // If this is a request for an app path that should be statically generated\n  // and we aren't in the edge runtime, strip the flight headers so it will\n  // generate the static response.\n  if (\n    !routeModule.isDev &&\n    !isDraftMode &&\n    isSSG &&\n    isRSCRequest &&\n    !isDynamicRSCRequest\n  ) {\n    stripFlightHeaders(req.headers)\n  }\n\n  const ComponentMod = {\n    ...entryBase,\n    tree,\n    pages,\n    GlobalError,\n    handler,\n    routeModule,\n    __next_app__,\n  }\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  try {\n    const varyHeader = routeModule.getVaryHeader(\n      resolvedPathname,\n      interceptionRoutePatterns\n    )\n    res.setHeader('Vary', varyHeader)\n    const invokeRouteModule = async (\n      span: Span | undefined,\n      context: AppPageRouteHandlerContext\n    ) => {\n      const nextReq = new NodeNextRequest(req)\n      const nextRes = new NodeNextResponse(res)\n\n      // TODO: adapt for putting the RDC inside the postponed data\n      // If we're in dev, and this isn't a prefetch or a server action,\n      // we should seed the resume data cache.\n      if (process.env.NODE_ENV === 'development') {\n        if (\n          nextConfig.experimental.cacheComponents &&\n          !isPrefetchRSCRequest &&\n          !context.renderOpts.isPossibleServerAction\n        ) {\n          const warmup = await routeModule.warmup(nextReq, nextRes, context)\n\n          // If the warmup is successful, we should use the resume data\n          // cache from the warmup.\n          if (warmup.metadata.renderResumeDataCache) {\n            context.renderOpts.renderResumeDataCache =\n              warmup.metadata.renderResumeDataCache\n          }\n        }\n      }\n\n      return routeModule.render(nextReq, nextRes, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${req.url}`)\n        }\n      })\n    }\n\n    const doRender = async ({\n      span,\n      postponed,\n      fallbackRouteParams,\n    }: {\n      span?: Span\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: FallbackRouteParams | null\n    }): Promise<ResponseCacheEntry> => {\n      const context: AppPageRouteHandlerContext = {\n        query,\n        params,\n        page: normalizedSrcPage,\n        sharedContext: {\n          buildId,\n        },\n        serverComponentsHmrCache: getRequestMeta(\n          req,\n          'serverComponentsHmrCache'\n        ),\n        fallbackRouteParams,\n        renderOpts: {\n          App: () => null,\n          Document: () => null,\n          pageConfig: {},\n          ComponentMod,\n          Component: interopDefault(ComponentMod),\n\n          params,\n          routeModule,\n          page: srcPage,\n          postponed,\n          shouldWaitOnAllReady,\n          serveStreamingMetadata,\n          supportsDynamicResponse:\n            typeof postponed === 'string' || supportsDynamicResponse,\n          buildManifest,\n          nextFontManifest,\n          reactLoadableManifest,\n          subresourceIntegrityManifest,\n          serverActionsManifest,\n          clientReferenceManifest,\n          setIsrStatus: routerServerContext?.setIsrStatus,\n\n          dir:\n            process.env.NEXT_RUNTIME === 'nodejs'\n              ? (require('path') as typeof import('path')).join(\n                  /* turbopackIgnore: true */\n                  process.cwd(),\n                  routeModule.relativeProjectDir\n                )\n              : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n          isDraftMode,\n          isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n          botType,\n          isOnDemandRevalidate,\n          isPossibleServerAction,\n          assetPrefix: nextConfig.assetPrefix,\n          nextConfigOutput: nextConfig.output,\n          crossOrigin: nextConfig.crossOrigin,\n          trailingSlash: nextConfig.trailingSlash,\n          previewProps: prerenderManifest.preview,\n          deploymentId: nextConfig.deploymentId,\n          enableTainting: nextConfig.experimental.taint,\n          htmlLimitedBots: nextConfig.htmlLimitedBots,\n          devtoolSegmentExplorer:\n            nextConfig.experimental.devtoolSegmentExplorer,\n          reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n\n          multiZoneDraftMode,\n          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n          cacheLifeProfiles: nextConfig.experimental.cacheLife,\n          basePath: nextConfig.basePath,\n          serverActions: nextConfig.experimental.serverActions,\n\n          ...(isDebugStaticShell || isDebugDynamicAccesses\n            ? {\n                nextExport: true,\n                supportsDynamicResponse: false,\n                isStaticGeneration: true,\n                isRevalidate: true,\n                isDebugDynamicAccesses: isDebugDynamicAccesses,\n              }\n            : {}),\n\n          experimental: {\n            isRoutePPREnabled,\n            expireTime: nextConfig.expireTime,\n            staleTimes: nextConfig.experimental.staleTimes,\n            cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n            clientSegmentCache: Boolean(\n              nextConfig.experimental.clientSegmentCache\n            ),\n            clientParamParsing: Boolean(\n              nextConfig.experimental.clientParamParsing\n            ),\n            dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n            inlineCss: Boolean(nextConfig.experimental.inlineCss),\n            authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n            clientTraceMetadata:\n              nextConfig.experimental.clientTraceMetadata || ([] as any),\n          },\n\n          waitUntil: ctx.waitUntil,\n          onClose: (cb) => {\n            res.on('close', cb)\n          },\n          onAfterTaskError: () => {},\n\n          onInstrumentationRequestError: (error, _request, errorContext) =>\n            routeModule.onRequestError(\n              req,\n              error,\n              errorContext,\n              routerServerContext\n            ),\n          err: getRequestMeta(req, 'invokeError'),\n          dev: routeModule.isDev,\n        },\n      }\n\n      const result = await invokeRouteModule(span, context)\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = metadata.fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !routeModule.isDev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.APP_PAGE,\n          html: result,\n          headers,\n          rscData: metadata.flightData,\n          postponed: metadata.postponed,\n          status: metadata.statusCode,\n          segmentData: metadata.segmentData,\n        } satisfies CachedAppPageValue,\n        cacheControl,\n      } satisfies ResponseCacheEntry\n    }\n\n    const responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry,\n      isRevalidating,\n      span,\n    }) => {\n      const isProduction = routeModule.isDev === false\n      const didRespond = hasResolved || res.writableEnded\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousCacheEntry &&\n        !minimalMode\n      ) {\n        if (routerServerContext?.render404) {\n          await routerServerContext.render404(req, res)\n        } else {\n          res.statusCode = 404\n          res.end('This page could not be found')\n        }\n        return null\n      }\n\n      let fallbackMode: FallbackMode | undefined\n\n      if (prerenderInfo) {\n        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n      }\n\n      // When serving a HTML bot request, we want to serve a blocking render and\n      // not the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n        if (!isRoutePPREnabled || isHtmlBot) {\n          fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n        }\n      }\n\n      if (previousCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (\n        !minimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        staticPathKey &&\n        !didRespond &&\n        !isDraftMode &&\n        pageIsDynamic &&\n        (isProduction || !isPrerendered)\n      ) {\n        // if the page has dynamicParams: false and this pathname wasn't\n        // prerendered trigger the no fallback handling\n        if (\n          // In development, fall through to render to handle missing\n          // getStaticPaths.\n          (isProduction || prerenderInfo) &&\n          // When fallback isn't present, abort this render so we 404\n          fallbackMode === FallbackMode.NOT_FOUND\n        ) {\n          throw new NoFallbackError()\n        }\n\n        let fallbackResponse: ResponseCacheEntry | null | undefined\n\n        if (isRoutePPREnabled && !isRSCRequest) {\n          const cacheKey =\n            typeof prerenderInfo?.fallback === 'string'\n              ? prerenderInfo.fallback\n              : isProduction\n                ? normalizedSrcPage\n                : null\n\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          fallbackResponse = await routeModule.handleResponse({\n            cacheKey,\n            req,\n            nextConfig,\n            routeKind: RouteKind.APP_PAGE,\n            isFallback: true,\n            prerenderManifest,\n            isRoutePPREnabled,\n            responseGenerator: async () =>\n              doRender({\n                span,\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                fallbackRouteParams:\n                  // If we're in production or we're debugging the fallback\n                  // shell then we should postpone when dynamic params are\n                  // accessed.\n                  isProduction || isDebugFallbackShell\n                    ? getFallbackRouteParams(normalizedSrcPage)\n                    : null,\n              }),\n            waitUntil: ctx.waitUntil,\n          })\n\n          // If the fallback response was set to null, then we should return null.\n          if (fallbackResponse === null) return null\n\n          // Otherwise, if we did get a fallback response, we should return it.\n          if (fallbackResponse) {\n            // Remove the cache control from the response to prevent it from being\n            // used in the surrounding cache.\n            delete fallbackResponse.cacheControl\n\n            return fallbackResponse\n          }\n        }\n      }\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      const postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.EMPTY,\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      // If this is a dynamic route with PPR enabled and the default route\n      // matches were set, then we should pass the fallback route params to\n      // the renderer as this is a fallback revalidation request.\n      const fallbackRouteParams =\n        pageIsDynamic &&\n        isRoutePPREnabled &&\n        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n          ? getFallbackRouteParams(pathname)\n          : null\n\n      // Perform the render.\n      return doRender({\n        span,\n        postponed,\n        fallbackRouteParams,\n      })\n    }\n\n    const handleResponse = async (span?: Span): Promise<null | void> => {\n      const cacheEntry = await routeModule.handleResponse({\n        cacheKey: ssgCacheKey,\n        responseGenerator: (c) =>\n          responseGenerator({\n            span,\n            ...c,\n          }),\n        routeKind: RouteKind.APP_PAGE,\n        isOnDemandRevalidate,\n        isRoutePPREnabled,\n        req,\n        nextConfig,\n        prerenderManifest,\n        waitUntil: ctx.waitUntil,\n      })\n\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      // In dev, we should not cache pages for any reason.\n      if (routeModule.isDev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n\n      if (!cacheEntry) {\n        if (ssgCacheKey) {\n          // A cache entry might not be generated if a response is written\n          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n          // have a cache key. If we do have a cache key but we don't end up\n          // with a cache entry, then either Next.js or the application has a\n          // bug that needs fixing.\n          throw new Error('invariant: cache entry required but not generated')\n        }\n        return null\n      }\n\n      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n        throw new Error(\n          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n        )\n      }\n\n      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n\n      if (\n        isSSG &&\n        // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest &&\n        (!didPostpone || isPrefetchRSCRequest)\n      ) {\n        if (!minimalMode) {\n          // set x-nextjs-cache header to match the header\n          // we set for the image-optimizer\n          res.setHeader(\n            'x-nextjs-cache',\n            isOnDemandRevalidate\n              ? 'REVALIDATED'\n              : cacheEntry.isMiss\n                ? 'MISS'\n                : cacheEntry.isStale\n                  ? 'STALE'\n                  : 'HIT'\n          )\n        }\n        // Set a header used by the client router to signal the response is static\n        // and should respect the `static` cache staleTime value.\n        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n      }\n      const { value: cachedData } = cacheEntry\n\n      // Coerce the cache control parameter from the render.\n      let cacheControl: CacheControl | undefined\n\n      // If this is a resume request in minimal mode it is streamed with dynamic\n      // content and should not be cached.\n      if (minimalPostponed) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this is in minimal mode and this is a flight request that isn't a\n      // prefetch request while PPR is enabled, it cannot be cached as it contains\n      // dynamic content.\n      else if (\n        minimalMode &&\n        isRSCRequest &&\n        !isPrefetchRSCRequest &&\n        isRoutePPREnabled\n      ) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (!routeModule.isDev) {\n        // If this is a preview mode request, we shouldn't cache it\n        if (isDraftMode) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n\n        // If this isn't SSG, then we should set change the header only if it is\n        // not set already.\n        else if (!isSSG) {\n          if (!res.getHeader('Cache-Control')) {\n            cacheControl = { revalidate: 0, expire: undefined }\n          }\n        } else if (cacheEntry.cacheControl) {\n          // If the cache entry has a cache control with a revalidate value that's\n          // a number, use it.\n          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n            if (cacheEntry.cacheControl.revalidate < 1) {\n              throw new Error(\n                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n              )\n            }\n\n            cacheControl = {\n              revalidate: cacheEntry.cacheControl.revalidate,\n              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n            }\n          }\n          // Otherwise if the revalidate value is false, then we should use the\n          // cache time of one year.\n          else {\n            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n          }\n        }\n      }\n\n      cacheEntry.cacheControl = cacheControl\n\n      if (\n        typeof segmentPrefetchHeader === 'string' &&\n        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n        cachedData.segmentData\n      ) {\n        // This is a prefetch request issued by the client Segment Cache. These\n        // should never reach the application layer (lambda). We should either\n        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n        // Set a header to indicate that PPR is enabled for this route. This\n        // lets the client distinguish between a regular cache miss and a cache\n        // miss due to PPR being disabled. In other contexts this header is used\n        // to indicate that the response contains dynamic data, but here we're\n        // only using it to indicate that the feature is enabled â€” the segment\n        // response itself contains whether the data is dynamic.\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n        // Add the cache tags header to the response if it exists and we're in\n        // minimal mode while rendering a static page.\n        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n        if (minimalMode && isSSG && tags && typeof tags === 'string') {\n          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n        }\n\n        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n        if (matchedSegment !== undefined) {\n          // Cache hit\n          return sendRenderResult({\n            req,\n            res,\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: RenderResult.fromStatic(\n              matchedSegment,\n              RSC_CONTENT_TYPE_HEADER\n            ),\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // Cache miss. Either a cache entry for this route has not been generated\n        // (which technically should not be possible when PPR is enabled, because\n        // at a minimum there should always be a fallback entry) or there's no\n        // match for the requested segment. Respond with a 204 No Content. We\n        // don't bother to respond with 404, because these requests are only\n        // issued as part of a prefetch.\n        res.statusCode = 204\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.EMPTY,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If there's a callback for `onCacheEntry`, call it with the cache entry\n      // and the revalidate options.\n      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n      if (onCacheEntry) {\n        const finished = await onCacheEntry(\n          {\n            ...cacheEntry,\n            // TODO: remove this when upstream doesn't\n            // always expect this value to be \"PAGE\"\n            value: {\n              ...cacheEntry.value,\n              kind: 'PAGE',\n            },\n          },\n          {\n            url: getRequestMeta(req, 'initURL'),\n          }\n        )\n        if (finished) {\n          // TODO: maybe we have to end the request?\n          return null\n        }\n      }\n\n      // If the request has a postponed state and it's a resume request we\n      // should error.\n      if (didPostpone && minimalPostponed) {\n        throw new Error(\n          'Invariant: postponed state should not be present on a resume request'\n        )\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!minimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (minimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n      if (\n        !minimalMode &&\n        cachedData.status &&\n        RedirectStatusCode[cachedData.status] &&\n        isRSCRequest\n      ) {\n        res.statusCode = 200\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isDraftMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          if (cachedData.postponed) {\n            throw new Error('Invariant: Expected postponed to be undefined')\n          }\n\n          return sendRenderResult({\n            req,\n            res,\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: cachedData.html,\n            // Dynamic RSC responses cannot be cached, even if they're\n            // configured with `force-static` because we have no way of\n            // distinguishing between `force-static` and pages that have no\n            // postponed state.\n            // TODO: distinguish `force-static` from pages with no postponed state (static)\n            cacheControl: isDynamicRSCRequest\n              ? { revalidate: 0, expire: undefined }\n              : cacheEntry.cacheControl,\n          })\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(\n            cachedData.rscData,\n            RSC_CONTENT_TYPE_HEADER\n          ),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // This is a request for HTML data.\n      let body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || minimalMode || isRSCRequest) {\n        // If we're in test mode, we should add a sentinel chunk to the response\n        // that's between the static and dynamic parts so we can compare the\n        // chunks and add assertions.\n        if (\n          process.env.__NEXT_TEST_MODE &&\n          minimalMode &&\n          isRoutePPREnabled &&\n          body.contentType === HTML_CONTENT_TYPE_HEADER\n        ) {\n          // As we're in minimal mode, the static part would have already been\n          // streamed first. The only part that this streams is the dynamic part\n          // so we should FIRST stream the sentinel and THEN the dynamic part.\n          body.unshift(createPPRBoundarySentinel())\n        }\n\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.push(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        })\n      }\n\n      // If we're in test mode, we should add a sentinel chunk to the response\n      // that's between the static and dynamic parts so we can compare the\n      // chunks and add assertions.\n      if (process.env.__NEXT_TEST_MODE) {\n        body.push(createPPRBoundarySentinel())\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.push(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        span,\n        postponed: cachedData.postponed,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return sendRenderResult({\n        req,\n        res,\n        generateEtags: nextConfig.generateEtags,\n        poweredByHeader: nextConfig.poweredByHeader,\n        result: body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      })\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      return await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${req.url}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: srcPage,\n          routeType: 'render',\n          revalidateReason: getRevalidateReason({\n            isRevalidate: isSSG,\n            isOnDemandRevalidate,\n          }),\n        },\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n    throw err\n  }\n}\n\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */\nfunction createPPRBoundarySentinel() {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(\n        new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->')\n      )\n      controller.close()\n    },\n  })\n}\n"],"names":["AppPageRouteModule","RouteKind","getRevalidateReason","getTracer","SpanKind","getRequestMeta","BaseServerSpan","interopDefault","stripFlightHeaders","NodeNextRequest","NodeNextResponse","checkIsAppPPREnabled","getFallbackRouteParams","setReferenceManifestsSingleton","isHtmlBotRequest","shouldServeStreamingMetadata","createServerModuleMap","normalizeAppPath","getIsPossibleServerAction","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_DID_POSTPONE_HEADER","RSC_CONTENT_TYPE_HEADER","getBotType","isBot","CachedRouteKind","FallbackMode","parseFallbackField","RenderResult","CACHE_ONE_YEAR","HTML_CONTENT_TYPE_HEADER","NEXT_CACHE_TAGS_HEADER","ENCODED_TAGS","sendRenderResult","NoFallbackError","tree","pages","GlobalError","__next_app__","require","__next_app_require__","loadChunk","__next_app_load_chunk__","entryBase","RedirectStatusCode","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","prerenderManifest","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","initialPostponed","minimalMode","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","query","params","parsedUrl","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","isDraftMode","resolvedPathname","revalidateOnlyGenerated","routerServerContext","nextConfig","interceptionRoutePatterns","normalizedSrcPage","isOnDemandRevalidate","prerenderInfo","match","isPrerendered","routes","isSSG","Boolean","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","experimental","ppr","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","dynamicRoutes","renderingMode","isDev","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","undefined","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","staticPathKey","ComponentMod","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","varyHeader","getVaryHeader","setHeader","invokeRouteModule","span","context","nextReq","nextRes","NODE_ENV","cacheComponents","renderOpts","warmup","metadata","renderResumeDataCache","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","url","doRender","postponed","fallbackRouteParams","sharedContext","serverComponentsHmrCache","App","Document","pageConfig","Component","setIsrStatus","dir","NEXT_RUNTIME","join","cwd","isRevalidate","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","previewProps","preview","deploymentId","enableTainting","taint","devtoolSegmentExplorer","reactMaxHeadersLength","incrementalCache","cacheLifeProfiles","cacheLife","basePath","serverActions","nextExport","isStaticGeneration","expireTime","staleTimes","clientSegmentCache","clientParamParsing","dynamicOnHover","inlineCss","authInterrupts","clientTraceMetadata","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","onRequestError","err","dev","result","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","Error","description","stack","message","substring","indexOf","value","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","render404","fallbackMode","fallback","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","fallbackResponse","cacheKey","handleResponse","routeKind","isFallback","expire","PAGES","EMPTY","pageData","cacheEntry","cachedData","c","didPostpone","isMiss","getHeader","tags","matchedSegment","generateEtags","poweredByHeader","fromStatic","onCacheEntry","finished","key","Object","entries","Array","isArray","v","appendHeader","toString","body","__NEXT_TEST_MODE","contentType","unshift","createPPRBoundarySentinel","push","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason","TextEncoder","encode"],"mappings":"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","ignoreList":[0]}